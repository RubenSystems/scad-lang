//===- scad.pst - SCaD Grammar Specification -*- PEST -*-=====================//
//
// This file defines the grammar rules for a custom language using PEST.
// Part of the SCaD Compiler
//
//===----------------------------------------------------------------------===//
///
/// \file
/// Defines the grammar using the PEST library for parsing SCaD.
/// This grammar defines the syntax and rules for various constructs in the
/// language.
///
//===----------------------------------------------------------------------===//


// MISC
WHITESPACE = _{ " " | "\t" | "\n" | "\r" | "\r\n"  }
COMMENT = _{ "/*" ~ (!"*/" ~ ANY)* ~ "*/" }

// Terminals
integer = @{ ASCII_DIGIT+ }
float = @{ ASCII_DIGIT+ ~ "." ~ ASCII_DIGIT+ }
char_array = { "\"" ~ (!"\"" ~ ANY)* ~ "\"" }
identifier = { (ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | "_")*) }
boolean_t = { "true" | "false" }

// type
type = _{ array_type | simple_type }
array_type = { "[" ~ type ~ ";" ~ integer ~ "]" }
simple_type = { identifier }

// Variable declerations
const_decl = { "let" ~ identifier ~ ":" ~ type ~ "=" ~ expression }
var_decl = { "let mut" ~ identifier ~ ":" ~ type ~ "=" ~ expression }


// block
block = _{ statement_block | expression_block } 

statement_block = { "{" ~ statements ~ "}" } 
expression_block = { "{" ~ statements ~ expression ~ "}" } 


// if statement
if_control_flow = _{
	if_block ~ else_if_block* ~ else_block?
}

if_block = {
	"if" ~ expression ~ block
}

else_if_block = {
	"else if" ~ expression ~ block
}

else_block = {
	"else" ~ block
}

// loopz
loop = _{ nonconditional_loop | conditional_loop }

nonconditional_loop = {
	"loop" ~ block
}

conditional_loop = {
	"loop" ~ expression ~ block
}

// Functios
function_definition = {
	"fn" ~ function_name ~ "(" ~ function_def_params? ~ ")" ~ type? ~ block 
}

function_call = {
	function_name ~ "(" ~ function_call_params? ~ ")"
}

function_name = {identifier}

// param: name: type
function_def_params = {
	function_def_param ~ ("," ~ function_def_param)*
}

function_call_params = {
	function_call_param ~ ("," ~ function_call_param)*
}

function_def_param = { 
	identifier ~ ":" ~ type
}

function_call_param = { 
	identifier ~ ":" ~ expression
}


infix_operator = _{ add | subtract | multiply | divide | and | or }
infix_operation = { 
	(non_infix_expressions ~ infix_operator ~ non_infix_expressions ) ~ (infix_operator ~ non_infix_expressions)* 
}
add = { "+" }
subtract = { "-" }
multiply = { "*" }
divide = { "/" }
and = { "&&" }
or = { "||" }

binary_infix_operator = _{  greater_equal | greater | greater | less  | equal }
binary_infix_operation = { 
	non_infix_expressions ~ binary_infix_operator ~ non_infix_expressions 
}
greater = { ">" }
greater_equal = { ">=" }
less = { "<" }
less_equal = { "<=" }
equal = { "==" }


// Major building blocks

non_infix_expressions = _{ "(" ~ expression ~ ")" | expression_block | float | integer | char_array | identifier }
expression = { binary_infix_operation | infix_operation | non_infix_expressions  }

statement = { function_definition | function_call | var_decl | const_decl | if_control_flow | loop | expression }
statements = _{ (statement ~ (WHITESPACE? ~ ";" ~ WHITESPACE?))* }
program = _{ SOI ~ statements ~ EOI }



// // numerics
// numeric_op = _{ add | subtract | multiply | divide }
// 	add = { "+" }
// 	subtract = { "-" }
// 	multiply = { "*" }
// 	divide = { "/" }

// unary_minus = { "-" }
// numeric = _{ float | integer | "(" ~ numeric_expression ~ ")" | identifier }
// numeric_atom = {unary_minus? ~ numeric}
// numeric_expression = {numeric_atom ~ (numeric_op ~ numeric_atom)*}


// // booleans
// unary_boolean_op = { not }
// 	not = { "!" }

// boolean_joins = _{ and | or } // andor 
// 	and = { "&&" }
// 	or = { "||" }

// binary_boolean_op = _{ less_than_equal | greather_than_equal | greater_than | less_than | equality }
// 	greater_than = { ">" }
// 	less_than = { "<" }
// 	equality = { "==" }
// 	less_than_equal = { "<=" }
// 	greather_than_equal = { ">=" }

// binary_boolean_comparitors = _{ float | integer | numeric_expression | identifier }
// binary_boolean_expression = { binary_boolean_comparitors ~ binary_boolean_op ~ binary_boolean_comparitors }


// boolean = _{ binary_boolean_expression | boolean_t | "(" ~ boolean_expression ~ ")" | identifier }
// boolean_atom = _{ not? ~ boolean }
// boolean_expression  = { boolean_atom ~ (boolean_joins ~ boolean_atom)* }
